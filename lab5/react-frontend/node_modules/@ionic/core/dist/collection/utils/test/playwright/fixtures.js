/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */
import { test as base } from '@playwright/test';
import { EventSpy, initPageEvents, addE2EListener } from './eventSpy';
export const test = base.extend({
  page: async ({ page }, use, testInfo) => {
    const oldGoTo = page.goto.bind(page);
    /**
     * This is an extended version of Playwright's
     * page.goto method. In addition to performing
     * the normal page.goto work, this code also
     * automatically waits for the Stencil components
     * to be hydrated before proceeding with the test.
     */
    page.goto = async (url) => {
      var _a, _b, _c;
      const { mode, rtl, _testing } = testInfo.project.metadata;
      const splitUrl = url.split('?');
      const paramsString = splitUrl[1];
      /**
       * This allows developers to force a
       * certain mode or LTR/RTL config per test.
       */
      const urlToParams = new URLSearchParams(paramsString);
      const formattedMode = (_a = urlToParams.get('ionic:mode')) !== null && _a !== void 0 ? _a : mode;
      const formattedRtl = (_b = urlToParams.get('rtl')) !== null && _b !== void 0 ? _b : rtl;
      const ionicTesting = (_c = urlToParams.get('ionic:_testing')) !== null && _c !== void 0 ? _c : _testing;
      const formattedUrl = `${splitUrl[0]}?ionic:_testing=${ionicTesting}&ionic:mode=${formattedMode}&rtl=${formattedRtl}`;
      const results = await Promise.all([
        page.waitForFunction(() => window.testAppLoaded === true),
        oldGoTo(formattedUrl),
      ]);
      return results[1];
    };
    /**
     * This provides metadata that can be used to
     * create a unique screenshot URL.
     * For example, we need to be able to differentiate
     * between iOS in LTR mode and iOS in RTL mode.
     */
    page.getSnapshotSettings = () => {
      var _a, _b;
      const url = page.url();
      const splitUrl = url.split('?');
      const paramsString = splitUrl[1];
      const { mode, rtl } = testInfo.project.metadata;
      /**
       * Account for custom settings when overriding
       * the mode/rtl setting. Fall back to the
       * project metadata if nothing was found. This
       * will happen if you call page.getSnapshotSettings
       * before page.goto.
       */
      const urlToParams = new URLSearchParams(paramsString);
      const formattedMode = (_a = urlToParams.get('ionic:mode')) !== null && _a !== void 0 ? _a : mode;
      const formattedRtl = (_b = urlToParams.get('rtl')) !== null && _b !== void 0 ? _b : rtl;
      /**
       * If encoded in the search params, the rtl value
       * can be `'true'` instead of `true`.
       */
      const rtlString = formattedRtl === true || formattedRtl === 'true' ? 'rtl' : 'ltr';
      return `${formattedMode}-${rtlString}`;
    };
    /**
     * Taking fullpage screenshots in Playwright
     * does not work with ion-content by default.
     * The reason is that full page screenshots do not
     * expand any scrollable container on the page. Instead,
     * they render the full scrollable content of the document itself.
     * To work around this, we increase the size of the document
     * so the full scrollable content inside of ion-content
     * can be captured in a screenshot.
     */
    page.setIonViewport = async () => {
      var _a, _b;
      const currentViewport = page.viewportSize();
      const pixelAmountRenderedOffscreen = await page.evaluate(() => {
        const content = document.querySelector('ion-content');
        if (content) {
          const innerScroll = content.shadowRoot.querySelector('.inner-scroll');
          return innerScroll.scrollHeight - content.clientHeight;
        }
        return 0;
      });
      const width = (_a = currentViewport === null || currentViewport === void 0 ? void 0 : currentViewport.width) !== null && _a !== void 0 ? _a : 640;
      const height = ((_b = currentViewport === null || currentViewport === void 0 ? void 0 : currentViewport.height) !== null && _b !== void 0 ? _b : 480) + pixelAmountRenderedOffscreen;
      await page.setViewportSize({
        width,
        height,
      });
    };
    /**
     * Creates a new EventSpy and listens
     * on the window for an event.
     * The test will timeout if the event
     * never fires.
     *
     * Usage:
     * const ionChange = await page.spyOnEvent('ionChange');
     * ...
     * await ionChange.next();
     */
    page.spyOnEvent = async (eventName) => {
      const spy = new EventSpy(eventName);
      await addE2EListener(page, eventName, (ev) => spy.push(ev));
      return spy;
    };
    initPageEvents(page);
    await use(page);
  },
});
