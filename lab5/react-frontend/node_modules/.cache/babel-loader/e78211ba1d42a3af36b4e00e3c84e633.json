{"ast":null,"code":"import { useCallback, useEffect, useRef, useState } from 'react';\nconst defaultOptions = {\n  cancelOnUnmount: true\n};\n/**\n * An async-utility hook that accepts a callback function and a delay time (in milliseconds), then repeats the\n * execution of the given function by the defined milliseconds.\n */\n\nconst useInterval = function (fn, milliseconds) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultOptions;\n  const opts = Object.assign(Object.assign({}, defaultOptions), options || {});\n  const timeout = useRef();\n  const callback = useRef(fn);\n  const [isCleared, setIsCleared] = useState(false); // the clear method\n\n  const clear = useCallback(() => {\n    if (timeout.current) {\n      setIsCleared(true);\n      clearInterval(timeout.current);\n    }\n  }, []); // if the provided function changes, change its reference\n\n  useEffect(() => {\n    if (typeof fn === 'function') {\n      callback.current = fn;\n    }\n  }, [fn]); // when the milliseconds change, reset the timeout\n\n  useEffect(() => {\n    if (typeof milliseconds === 'number') {\n      timeout.current = setInterval(() => {\n        callback.current();\n      }, milliseconds);\n    } // cleanup previous interval\n\n\n    return clear;\n  }, [milliseconds]); // when component unmount clear the timeout\n\n  useEffect(() => () => {\n    if (opts.cancelOnUnmount) {\n      clear();\n    }\n  }, []);\n  return [isCleared, clear];\n};\n\nexport default useInterval;","map":{"version":3,"sources":["/home/nikita/Desktop/devOps-labs/lab5/react-frontend/node_modules/beautiful-react-hooks/esm/useInterval.js"],"names":["useCallback","useEffect","useRef","useState","defaultOptions","cancelOnUnmount","useInterval","fn","milliseconds","options","opts","Object","assign","timeout","callback","isCleared","setIsCleared","clear","current","clearInterval","setInterval"],"mappings":"AAAA,SAASA,WAAT,EAAsBC,SAAtB,EAAiCC,MAAjC,EAAyCC,QAAzC,QAAyD,OAAzD;AACA,MAAMC,cAAc,GAAG;AACnBC,EAAAA,eAAe,EAAE;AADE,CAAvB;AAGA;AACA;AACA;AACA;;AACA,MAAMC,WAAW,GAAG,UAACC,EAAD,EAAKC,YAAL,EAAgD;AAAA,MAA7BC,OAA6B,uEAAnBL,cAAmB;AAChE,QAAMM,IAAI,GAAGC,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBR,cAAlB,CAAd,EAAkDK,OAAO,IAAI,EAA7D,CAAb;AACA,QAAMI,OAAO,GAAGX,MAAM,EAAtB;AACA,QAAMY,QAAQ,GAAGZ,MAAM,CAACK,EAAD,CAAvB;AACA,QAAM,CAACQ,SAAD,EAAYC,YAAZ,IAA4Bb,QAAQ,CAAC,KAAD,CAA1C,CAJgE,CAKhE;;AACA,QAAMc,KAAK,GAAGjB,WAAW,CAAC,MAAM;AAC5B,QAAIa,OAAO,CAACK,OAAZ,EAAqB;AACjBF,MAAAA,YAAY,CAAC,IAAD,CAAZ;AACAG,MAAAA,aAAa,CAACN,OAAO,CAACK,OAAT,CAAb;AACH;AACJ,GALwB,EAKtB,EALsB,CAAzB,CANgE,CAYhE;;AACAjB,EAAAA,SAAS,CAAC,MAAM;AACZ,QAAI,OAAOM,EAAP,KAAc,UAAlB,EAA8B;AAC1BO,MAAAA,QAAQ,CAACI,OAAT,GAAmBX,EAAnB;AACH;AACJ,GAJQ,EAIN,CAACA,EAAD,CAJM,CAAT,CAbgE,CAkBhE;;AACAN,EAAAA,SAAS,CAAC,MAAM;AACZ,QAAI,OAAOO,YAAP,KAAwB,QAA5B,EAAsC;AAClCK,MAAAA,OAAO,CAACK,OAAR,GAAkBE,WAAW,CAAC,MAAM;AAChCN,QAAAA,QAAQ,CAACI,OAAT;AACH,OAF4B,EAE1BV,YAF0B,CAA7B;AAGH,KALW,CAMZ;;;AACA,WAAOS,KAAP;AACH,GARQ,EAQN,CAACT,YAAD,CARM,CAAT,CAnBgE,CA4BhE;;AACAP,EAAAA,SAAS,CAAC,MAAM,MAAM;AAClB,QAAIS,IAAI,CAACL,eAAT,EAA0B;AACtBY,MAAAA,KAAK;AACR;AACJ,GAJQ,EAIN,EAJM,CAAT;AAKA,SAAO,CAACF,SAAD,EAAYE,KAAZ,CAAP;AACH,CAnCD;;AAoCA,eAAeX,WAAf","sourcesContent":["import { useCallback, useEffect, useRef, useState } from 'react';\nconst defaultOptions = {\n    cancelOnUnmount: true,\n};\n/**\n * An async-utility hook that accepts a callback function and a delay time (in milliseconds), then repeats the\n * execution of the given function by the defined milliseconds.\n */\nconst useInterval = (fn, milliseconds, options = defaultOptions) => {\n    const opts = Object.assign(Object.assign({}, defaultOptions), (options || {}));\n    const timeout = useRef();\n    const callback = useRef(fn);\n    const [isCleared, setIsCleared] = useState(false);\n    // the clear method\n    const clear = useCallback(() => {\n        if (timeout.current) {\n            setIsCleared(true);\n            clearInterval(timeout.current);\n        }\n    }, []);\n    // if the provided function changes, change its reference\n    useEffect(() => {\n        if (typeof fn === 'function') {\n            callback.current = fn;\n        }\n    }, [fn]);\n    // when the milliseconds change, reset the timeout\n    useEffect(() => {\n        if (typeof milliseconds === 'number') {\n            timeout.current = setInterval(() => {\n                callback.current();\n            }, milliseconds);\n        }\n        // cleanup previous interval\n        return clear;\n    }, [milliseconds]);\n    // when component unmount clear the timeout\n    useEffect(() => () => {\n        if (opts.cancelOnUnmount) {\n            clear();\n        }\n    }, []);\n    return [isCleared, clear];\n};\nexport default useInterval;\n"]},"metadata":{},"sourceType":"module"}