{"ast":null,"code":"import { useRef, useState } from 'react';\nimport useMouseEvents from './useMouseEvents';\nimport useTouchEvents from './useTouchEvents';\nimport { getDirection, getHorizontalDirection, getPointerCoordinates, getVerticalDirection } from './shared/swipeUtils';\nconst defaultOptions = {\n  direction: 'both',\n  threshold: 10,\n  preventDefault: true\n};\nconst initialState = {\n  swiping: false,\n  direction: undefined,\n  alphaX: 0,\n  alphaY: 0,\n  count: 0\n};\n\nconst isEqual = (prev, next) => prev.swiping === next.swiping && prev.direction === next.direction && prev.count === next.count && prev.alphaX === next.alphaX && prev.alphaY === next.alphaY;\n/**\n * useSwipe hook\n */\n\n\nconst useSwipe = function () {\n  let targetRef = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;\n  const [state, setState] = useState(initialState);\n  const startingPointRef = useRef([-1, -1]);\n  const isDraggingRef = useRef(false);\n  const opts = Object.assign(Object.assign({}, defaultOptions), options || {});\n  const {\n    onMouseDown,\n    onMouseMove,\n    onMouseLeave,\n    onMouseUp\n  } = useMouseEvents(targetRef);\n  const {\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n    onTouchCancel\n  } = useTouchEvents(targetRef);\n\n  const startSwipe = event => {\n    const [clientX, clientY] = getPointerCoordinates(event);\n    startingPointRef.current = [clientX, clientY];\n\n    if (opts.preventDefault) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  };\n\n  const continueSwipe = event => {\n    const [clientX, clientY] = getPointerCoordinates(event);\n\n    if (opts.preventDefault) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    if (isDraggingRef.current || startingPointRef.current[0] !== -1 && startingPointRef.current[1] !== -1) {\n      const alpha = [startingPointRef.current[0] - clientX, startingPointRef.current[1] - clientY];\n\n      if (opts.direction === 'both' && (Math.abs(alpha[0]) > opts.threshold || Math.abs(alpha[1]) > opts.threshold)) {\n        isDraggingRef.current = true;\n        const nextState = {\n          alphaX: alpha[0],\n          alphaY: alpha[1],\n          count: state.count,\n          swiping: true,\n          direction: getDirection([clientX, clientY], startingPointRef.current, alpha)\n        };\n\n        if (!isEqual(nextState, state)) {\n          setState(nextState);\n        }\n      }\n\n      if (opts.direction === 'horizontal' && Math.abs(alpha[0]) > opts.threshold) {\n        isDraggingRef.current = true;\n        const nextState = {\n          alphaX: alpha[0],\n          alphaY: 0,\n          count: state.count,\n          swiping: true,\n          direction: getHorizontalDirection(alpha[0])\n        };\n\n        if (!isEqual(nextState, state)) {\n          setState(nextState);\n        }\n      }\n\n      if (opts.direction === 'vertical' && Math.abs(alpha[1]) > opts.threshold) {\n        isDraggingRef.current = true;\n        const nextState = {\n          alphaY: alpha[1],\n          alphaX: 0,\n          count: state.count,\n          swiping: true,\n          direction: getVerticalDirection(alpha[1])\n        };\n\n        if (!isEqual(nextState, state)) {\n          setState(nextState);\n        }\n      }\n    }\n  };\n\n  const endSwipe = event => {\n    if (isDraggingRef.current) {\n      if (opts.preventDefault) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n\n      setState(prevState => Object.assign(Object.assign({}, prevState), {\n        swiping: false,\n        count: state.count + 1\n      }));\n    }\n\n    startingPointRef.current = [-1, -1];\n    isDraggingRef.current = false;\n  };\n\n  onMouseDown(startSwipe);\n  onTouchStart(startSwipe);\n  onMouseMove(continueSwipe);\n  onTouchMove(continueSwipe);\n  onMouseUp(endSwipe);\n  onTouchEnd(endSwipe);\n  onMouseLeave(endSwipe);\n  onTouchCancel(endSwipe);\n  return state;\n};\n\nexport default useSwipe;","map":{"version":3,"sources":["/home/nikita/Desktop/devOps-labs/lab5/react-frontend/node_modules/beautiful-react-hooks/esm/useSwipe.js"],"names":["useRef","useState","useMouseEvents","useTouchEvents","getDirection","getHorizontalDirection","getPointerCoordinates","getVerticalDirection","defaultOptions","direction","threshold","preventDefault","initialState","swiping","undefined","alphaX","alphaY","count","isEqual","prev","next","useSwipe","targetRef","options","state","setState","startingPointRef","isDraggingRef","opts","Object","assign","onMouseDown","onMouseMove","onMouseLeave","onMouseUp","onTouchStart","onTouchMove","onTouchEnd","onTouchCancel","startSwipe","event","clientX","clientY","current","stopPropagation","continueSwipe","alpha","Math","abs","nextState","endSwipe","prevState"],"mappings":"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","sourcesContent":["import { useRef, useState } from 'react';\nimport useMouseEvents from './useMouseEvents';\nimport useTouchEvents from './useTouchEvents';\nimport { getDirection, getHorizontalDirection, getPointerCoordinates, getVerticalDirection } from './shared/swipeUtils';\nconst defaultOptions = {\n    direction: 'both',\n    threshold: 10,\n    preventDefault: true,\n};\nconst initialState = { swiping: false, direction: undefined, alphaX: 0, alphaY: 0, count: 0 };\nconst isEqual = (prev, next) => (prev.swiping === next.swiping\n    && prev.direction === next.direction\n    && prev.count === next.count\n    && prev.alphaX === next.alphaX\n    && prev.alphaY === next.alphaY);\n/**\n * useSwipe hook\n */\nconst useSwipe = (targetRef = null, options = defaultOptions) => {\n    const [state, setState] = useState(initialState);\n    const startingPointRef = useRef([-1, -1]);\n    const isDraggingRef = useRef(false);\n    const opts = Object.assign(Object.assign({}, defaultOptions), (options || {}));\n    const { onMouseDown, onMouseMove, onMouseLeave, onMouseUp } = useMouseEvents(targetRef);\n    const { onTouchStart, onTouchMove, onTouchEnd, onTouchCancel } = useTouchEvents(targetRef);\n    const startSwipe = (event) => {\n        const [clientX, clientY] = getPointerCoordinates(event);\n        startingPointRef.current = [clientX, clientY];\n        if (opts.preventDefault) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n    };\n    const continueSwipe = (event) => {\n        const [clientX, clientY] = getPointerCoordinates(event);\n        if (opts.preventDefault) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n        if (isDraggingRef.current || (startingPointRef.current[0] !== -1 && startingPointRef.current[1] !== -1)) {\n            const alpha = [startingPointRef.current[0] - clientX, startingPointRef.current[1] - clientY];\n            if (opts.direction === 'both' && (Math.abs(alpha[0]) > opts.threshold || Math.abs(alpha[1]) > opts.threshold)) {\n                isDraggingRef.current = true;\n                const nextState = {\n                    alphaX: alpha[0],\n                    alphaY: alpha[1],\n                    count: state.count,\n                    swiping: true,\n                    direction: getDirection([clientX, clientY], startingPointRef.current, alpha),\n                };\n                if (!isEqual(nextState, state)) {\n                    setState(nextState);\n                }\n            }\n            if (opts.direction === 'horizontal' && Math.abs(alpha[0]) > opts.threshold) {\n                isDraggingRef.current = true;\n                const nextState = {\n                    alphaX: alpha[0],\n                    alphaY: 0,\n                    count: state.count,\n                    swiping: true,\n                    direction: getHorizontalDirection(alpha[0]),\n                };\n                if (!isEqual(nextState, state)) {\n                    setState(nextState);\n                }\n            }\n            if (opts.direction === 'vertical' && Math.abs(alpha[1]) > opts.threshold) {\n                isDraggingRef.current = true;\n                const nextState = {\n                    alphaY: alpha[1],\n                    alphaX: 0,\n                    count: state.count,\n                    swiping: true,\n                    direction: getVerticalDirection(alpha[1]),\n                };\n                if (!isEqual(nextState, state)) {\n                    setState(nextState);\n                }\n            }\n        }\n    };\n    const endSwipe = (event) => {\n        if (isDraggingRef.current) {\n            if (opts.preventDefault) {\n                event.preventDefault();\n                event.stopPropagation();\n            }\n            setState((prevState) => (Object.assign(Object.assign({}, prevState), { swiping: false, count: state.count + 1 })));\n        }\n        startingPointRef.current = [-1, -1];\n        isDraggingRef.current = false;\n    };\n    onMouseDown(startSwipe);\n    onTouchStart(startSwipe);\n    onMouseMove(continueSwipe);\n    onTouchMove(continueSwipe);\n    onMouseUp(endSwipe);\n    onTouchEnd(endSwipe);\n    onMouseLeave(endSwipe);\n    onTouchCancel(endSwipe);\n    return state;\n};\nexport default useSwipe;\n"]},"metadata":{},"sourceType":"module"}