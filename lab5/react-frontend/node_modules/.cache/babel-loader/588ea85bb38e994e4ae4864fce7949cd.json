{"ast":null,"code":"import { useCallback, useEffect, useRef, useState } from 'react';\nimport usePreviousValue from './usePreviousValue';\nconst defaultOptions = {\n  cancelOnUnmount: true,\n  cancelOnConditionChange: true\n};\n/**\n * An async-utility hook that accepts a callback function and a delay time (in milliseconds), then delays the\n * execution of the given function by the defined time from when the condition verifies.\n */\n\nconst useConditionalTimeout = function (fn, milliseconds, condition) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultOptions;\n  const opts = Object.assign(Object.assign({}, defaultOptions), options || {});\n  const timeout = useRef();\n  const callback = useRef(fn);\n  const [isCleared, setIsCleared] = useState(false);\n  const prevCondition = usePreviousValue(condition); // the clear method\n\n  const clear = useCallback(() => {\n    if (timeout.current) {\n      clearTimeout(timeout.current);\n      setIsCleared(true);\n    }\n  }, []); // if the provided function changes, change its reference\n\n  useEffect(() => {\n    if (typeof fn === 'function') {\n      callback.current = fn;\n    }\n  }, [fn]); // when the milliseconds change, reset the timeout\n\n  useEffect(() => {\n    if (condition && typeof milliseconds === 'number') {\n      timeout.current = setTimeout(() => {\n        callback.current();\n      }, milliseconds);\n    }\n  }, [condition, milliseconds]); // when the condition change, clear the timeout\n\n  useEffect(() => {\n    if (prevCondition && condition !== prevCondition && opts.cancelOnConditionChange) {\n      clear();\n    }\n  }, [condition, options]); // when component unmount clear the timeout\n\n  useEffect(() => () => {\n    if (opts.cancelOnUnmount) {\n      clear();\n    }\n  }, []);\n  return [isCleared, clear];\n};\n\nexport default useConditionalTimeout;","map":{"version":3,"sources":["/home/nikita/Desktop/devOps-labs/lab5/react-frontend/node_modules/beautiful-react-hooks/esm/useConditionalTimeout.js"],"names":["useCallback","useEffect","useRef","useState","usePreviousValue","defaultOptions","cancelOnUnmount","cancelOnConditionChange","useConditionalTimeout","fn","milliseconds","condition","options","opts","Object","assign","timeout","callback","isCleared","setIsCleared","prevCondition","clear","current","clearTimeout","setTimeout"],"mappings":"AAAA,SAASA,WAAT,EAAsBC,SAAtB,EAAiCC,MAAjC,EAAyCC,QAAzC,QAAyD,OAAzD;AACA,OAAOC,gBAAP,MAA6B,oBAA7B;AACA,MAAMC,cAAc,GAAG;AACnBC,EAAAA,eAAe,EAAE,IADE;AAEnBC,EAAAA,uBAAuB,EAAE;AAFN,CAAvB;AAIA;AACA;AACA;AACA;;AACA,MAAMC,qBAAqB,GAAG,UAACC,EAAD,EAAKC,YAAL,EAAmBC,SAAnB,EAA2D;AAAA,MAA7BC,OAA6B,uEAAnBP,cAAmB;AACrF,QAAMQ,IAAI,GAAGC,MAAM,CAACC,MAAP,CAAcD,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkBV,cAAlB,CAAd,EAAkDO,OAAO,IAAI,EAA7D,CAAb;AACA,QAAMI,OAAO,GAAGd,MAAM,EAAtB;AACA,QAAMe,QAAQ,GAAGf,MAAM,CAACO,EAAD,CAAvB;AACA,QAAM,CAACS,SAAD,EAAYC,YAAZ,IAA4BhB,QAAQ,CAAC,KAAD,CAA1C;AACA,QAAMiB,aAAa,GAAGhB,gBAAgB,CAACO,SAAD,CAAtC,CALqF,CAMrF;;AACA,QAAMU,KAAK,GAAGrB,WAAW,CAAC,MAAM;AAC5B,QAAIgB,OAAO,CAACM,OAAZ,EAAqB;AACjBC,MAAAA,YAAY,CAACP,OAAO,CAACM,OAAT,CAAZ;AACAH,MAAAA,YAAY,CAAC,IAAD,CAAZ;AACH;AACJ,GALwB,EAKtB,EALsB,CAAzB,CAPqF,CAarF;;AACAlB,EAAAA,SAAS,CAAC,MAAM;AACZ,QAAI,OAAOQ,EAAP,KAAc,UAAlB,EAA8B;AAC1BQ,MAAAA,QAAQ,CAACK,OAAT,GAAmBb,EAAnB;AACH;AACJ,GAJQ,EAIN,CAACA,EAAD,CAJM,CAAT,CAdqF,CAmBrF;;AACAR,EAAAA,SAAS,CAAC,MAAM;AACZ,QAAIU,SAAS,IAAI,OAAOD,YAAP,KAAwB,QAAzC,EAAmD;AAC/CM,MAAAA,OAAO,CAACM,OAAR,GAAkBE,UAAU,CAAC,MAAM;AAC/BP,QAAAA,QAAQ,CAACK,OAAT;AACH,OAF2B,EAEzBZ,YAFyB,CAA5B;AAGH;AACJ,GANQ,EAMN,CAACC,SAAD,EAAYD,YAAZ,CANM,CAAT,CApBqF,CA2BrF;;AACAT,EAAAA,SAAS,CAAC,MAAM;AACZ,QAAImB,aAAa,IAAIT,SAAS,KAAKS,aAA/B,IAAgDP,IAAI,CAACN,uBAAzD,EAAkF;AAC9Ec,MAAAA,KAAK;AACR;AACJ,GAJQ,EAIN,CAACV,SAAD,EAAYC,OAAZ,CAJM,CAAT,CA5BqF,CAiCrF;;AACAX,EAAAA,SAAS,CAAC,MAAM,MAAM;AAClB,QAAIY,IAAI,CAACP,eAAT,EAA0B;AACtBe,MAAAA,KAAK;AACR;AACJ,GAJQ,EAIN,EAJM,CAAT;AAKA,SAAO,CAACH,SAAD,EAAYG,KAAZ,CAAP;AACH,CAxCD;;AAyCA,eAAeb,qBAAf","sourcesContent":["import { useCallback, useEffect, useRef, useState } from 'react';\nimport usePreviousValue from './usePreviousValue';\nconst defaultOptions = {\n    cancelOnUnmount: true,\n    cancelOnConditionChange: true,\n};\n/**\n * An async-utility hook that accepts a callback function and a delay time (in milliseconds), then delays the\n * execution of the given function by the defined time from when the condition verifies.\n */\nconst useConditionalTimeout = (fn, milliseconds, condition, options = defaultOptions) => {\n    const opts = Object.assign(Object.assign({}, defaultOptions), (options || {}));\n    const timeout = useRef();\n    const callback = useRef(fn);\n    const [isCleared, setIsCleared] = useState(false);\n    const prevCondition = usePreviousValue(condition);\n    // the clear method\n    const clear = useCallback(() => {\n        if (timeout.current) {\n            clearTimeout(timeout.current);\n            setIsCleared(true);\n        }\n    }, []);\n    // if the provided function changes, change its reference\n    useEffect(() => {\n        if (typeof fn === 'function') {\n            callback.current = fn;\n        }\n    }, [fn]);\n    // when the milliseconds change, reset the timeout\n    useEffect(() => {\n        if (condition && typeof milliseconds === 'number') {\n            timeout.current = setTimeout(() => {\n                callback.current();\n            }, milliseconds);\n        }\n    }, [condition, milliseconds]);\n    // when the condition change, clear the timeout\n    useEffect(() => {\n        if (prevCondition && condition !== prevCondition && opts.cancelOnConditionChange) {\n            clear();\n        }\n    }, [condition, options]);\n    // when component unmount clear the timeout\n    useEffect(() => () => {\n        if (opts.cancelOnUnmount) {\n            clear();\n        }\n    }, []);\n    return [isCleared, clear];\n};\nexport default useConditionalTimeout;\n"]},"metadata":{},"sourceType":"module"}