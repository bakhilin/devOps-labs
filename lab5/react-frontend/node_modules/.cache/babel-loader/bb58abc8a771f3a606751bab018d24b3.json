{"ast":null,"code":"import { useEffect, useRef, useState } from 'react';\nimport useHandlerSetterRef from './shared/useHandlerSetterRef';\nimport useMouseEvents from './useMouseEvents';\nimport useTouchEvents from './useTouchEvents';\nimport { getDirection, getPointerCoordinates } from './shared/swipeUtils';\nconst defaultOptions = {\n  threshold: 15,\n  preventDefault: true\n};\n/**\n * Very similar to useSwipe but doesn't cause re-rendering during swipe\n */\n\nconst useSilentSwipeState = function () {\n  let targetRef = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;\n  let onSwipeStart = arguments.length > 2 ? arguments[2] : undefined;\n  let onSwipeMove = arguments.length > 3 ? arguments[3] : undefined;\n  let onSwipeEnd = arguments.length > 4 ? arguments[4] : undefined;\n  const startingPointRef = useRef([-1, -1]);\n  const directionRef = useRef(null);\n  const isDraggingRef = useRef(false);\n  const alphaRef = useRef([]);\n  const opts = Object.assign(Object.assign({}, defaultOptions), options || {});\n  const {\n    onMouseDown,\n    onMouseMove,\n    onMouseLeave,\n    onMouseUp\n  } = useMouseEvents(targetRef);\n  const {\n    onTouchStart,\n    onTouchMove,\n    onTouchEnd,\n    onTouchCancel\n  } = useTouchEvents(targetRef);\n  const [state, setState] = useState();\n\n  const startSwipe = event => {\n    const [clientX, clientY] = getPointerCoordinates(event);\n    startingPointRef.current = [clientX, clientY];\n    directionRef.current = null;\n\n    if (onSwipeStart) {\n      onSwipeStart({\n        clientX,\n        clientY\n      });\n    }\n\n    if (opts.preventDefault) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  };\n\n  const continueSwipe = event => {\n    const [clientX, clientY] = getPointerCoordinates(event);\n\n    if (opts.preventDefault) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    if (startingPointRef.current[0] !== -1 && startingPointRef.current[1] !== -1) {\n      const alpha = [startingPointRef.current[0] - clientX, startingPointRef.current[1] - clientY];\n\n      if (Math.abs(alpha[0]) > opts.threshold || Math.abs(alpha[1]) > opts.threshold) {\n        isDraggingRef.current = true;\n        directionRef.current = getDirection([clientX, clientY], startingPointRef.current, alpha);\n        alphaRef.current = alpha;\n\n        if (onSwipeMove) {\n          onSwipeMove({\n            clientX,\n            clientY,\n            direction: directionRef.current,\n            alphaX: alphaRef.current[0],\n            alphaY: alphaRef.current[1]\n          });\n        }\n      }\n    }\n  };\n\n  const endSwipe = event => {\n    if (isDraggingRef.current && directionRef.current) {\n      if (opts.preventDefault) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n\n      setState({\n        direction: directionRef.current,\n        alphaX: alphaRef.current[0],\n        alphaY: alphaRef.current[1]\n      });\n\n      if (onSwipeEnd) {\n        onSwipeEnd({\n          direction: directionRef.current,\n          alphaX: alphaRef.current[0],\n          alphaY: alphaRef.current[1]\n        });\n      }\n    }\n\n    startingPointRef.current = [-1, -1];\n    isDraggingRef.current = false;\n    directionRef.current = null;\n  };\n\n  onMouseDown(startSwipe);\n  onTouchStart(startSwipe);\n  onMouseMove(continueSwipe);\n  onTouchMove(continueSwipe);\n  onMouseUp(endSwipe);\n  onTouchEnd(endSwipe);\n  onMouseLeave(endSwipe);\n  onTouchCancel(endSwipe);\n  return state;\n};\n/**\n * useSwipeEvents\n * @param targetRef\n * @param options\n */\n\n\nconst useSwipeEvents = function () {\n  let targetRef = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOptions;\n  const opts = Object.assign(Object.assign({}, defaultOptions), options || {});\n  const [onSwipeLeft, setOnSwipeLeft] = useHandlerSetterRef();\n  const [onSwipeRight, setOnSwipeRight] = useHandlerSetterRef();\n  const [onSwipeUp, setOnSwipeUp] = useHandlerSetterRef();\n  const [onSwipeDown, setOnSwipeDown] = useHandlerSetterRef();\n  const [onSwipeStart, setOnSwipeStart] = useHandlerSetterRef();\n  const [onSwipeMove, setOnSwipeMove] = useHandlerSetterRef();\n  const [onSwipeEnd, setOnSwipeEnd] = useHandlerSetterRef();\n  const state = useSilentSwipeState(targetRef, opts, onSwipeStart.current, onSwipeMove.current, onSwipeEnd.current);\n  const fnMap = {\n    right: onSwipeRight,\n    left: onSwipeLeft,\n    up: onSwipeUp,\n    down: onSwipeDown\n  };\n  useEffect(() => {\n    if (state && state.direction) {\n      const cb = fnMap[state.direction].current;\n\n      if (cb && typeof cb === 'function') {\n        cb(state);\n      }\n    }\n  }, [state]);\n  return Object.freeze({\n    onSwipeLeft: setOnSwipeLeft,\n    onSwipeRight: setOnSwipeRight,\n    onSwipeUp: setOnSwipeUp,\n    onSwipeDown: setOnSwipeDown,\n    onSwipeMove: setOnSwipeMove,\n    onSwipeStart: setOnSwipeStart,\n    onSwipeEnd: setOnSwipeEnd\n  });\n};\n\nexport default useSwipeEvents;","map":{"version":3,"sources":["/home/nikita/Desktop/devOps-labs/lab5/react-frontend/node_modules/beautiful-react-hooks/esm/useSwipeEvents.js"],"names":["useEffect","useRef","useState","useHandlerSetterRef","useMouseEvents","useTouchEvents","getDirection","getPointerCoordinates","defaultOptions","threshold","preventDefault","useSilentSwipeState","targetRef","options","onSwipeStart","onSwipeMove","onSwipeEnd","startingPointRef","directionRef","isDraggingRef","alphaRef","opts","Object","assign","onMouseDown","onMouseMove","onMouseLeave","onMouseUp","onTouchStart","onTouchMove","onTouchEnd","onTouchCancel","state","setState","startSwipe","event","clientX","clientY","current","stopPropagation","continueSwipe","alpha","Math","abs","direction","alphaX","alphaY","endSwipe","useSwipeEvents","onSwipeLeft","setOnSwipeLeft","onSwipeRight","setOnSwipeRight","onSwipeUp","setOnSwipeUp","onSwipeDown","setOnSwipeDown","setOnSwipeStart","setOnSwipeMove","setOnSwipeEnd","fnMap","right","left","up","down","cb","freeze"],"mappings":"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","sourcesContent":["import { useEffect, useRef, useState } from 'react';\nimport useHandlerSetterRef from './shared/useHandlerSetterRef';\nimport useMouseEvents from './useMouseEvents';\nimport useTouchEvents from './useTouchEvents';\nimport { getDirection, getPointerCoordinates } from './shared/swipeUtils';\nconst defaultOptions = {\n    threshold: 15,\n    preventDefault: true,\n};\n/**\n * Very similar to useSwipe but doesn't cause re-rendering during swipe\n */\nconst useSilentSwipeState = (targetRef = null, options = defaultOptions, onSwipeStart, onSwipeMove, onSwipeEnd) => {\n    const startingPointRef = useRef([-1, -1]);\n    const directionRef = useRef(null);\n    const isDraggingRef = useRef(false);\n    const alphaRef = useRef([]);\n    const opts = Object.assign(Object.assign({}, defaultOptions), (options || {}));\n    const { onMouseDown, onMouseMove, onMouseLeave, onMouseUp } = useMouseEvents(targetRef);\n    const { onTouchStart, onTouchMove, onTouchEnd, onTouchCancel } = useTouchEvents(targetRef);\n    const [state, setState] = useState();\n    const startSwipe = (event) => {\n        const [clientX, clientY] = getPointerCoordinates(event);\n        startingPointRef.current = [clientX, clientY];\n        directionRef.current = null;\n        if (onSwipeStart) {\n            onSwipeStart({ clientX, clientY });\n        }\n        if (opts.preventDefault) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n    };\n    const continueSwipe = (event) => {\n        const [clientX, clientY] = getPointerCoordinates(event);\n        if (opts.preventDefault) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n        if (startingPointRef.current[0] !== -1 && startingPointRef.current[1] !== -1) {\n            const alpha = [startingPointRef.current[0] - clientX, startingPointRef.current[1] - clientY];\n            if (Math.abs(alpha[0]) > opts.threshold || Math.abs(alpha[1]) > opts.threshold) {\n                isDraggingRef.current = true;\n                directionRef.current = getDirection([clientX, clientY], startingPointRef.current, alpha);\n                alphaRef.current = alpha;\n                if (onSwipeMove) {\n                    onSwipeMove({\n                        clientX,\n                        clientY,\n                        direction: directionRef.current,\n                        alphaX: alphaRef.current[0],\n                        alphaY: alphaRef.current[1],\n                    });\n                }\n            }\n        }\n    };\n    const endSwipe = (event) => {\n        if (isDraggingRef.current && directionRef.current) {\n            if (opts.preventDefault) {\n                event.preventDefault();\n                event.stopPropagation();\n            }\n            setState({\n                direction: directionRef.current,\n                alphaX: alphaRef.current[0],\n                alphaY: alphaRef.current[1],\n            });\n            if (onSwipeEnd) {\n                onSwipeEnd({\n                    direction: directionRef.current,\n                    alphaX: alphaRef.current[0],\n                    alphaY: alphaRef.current[1],\n                });\n            }\n        }\n        startingPointRef.current = [-1, -1];\n        isDraggingRef.current = false;\n        directionRef.current = null;\n    };\n    onMouseDown(startSwipe);\n    onTouchStart(startSwipe);\n    onMouseMove(continueSwipe);\n    onTouchMove(continueSwipe);\n    onMouseUp(endSwipe);\n    onTouchEnd(endSwipe);\n    onMouseLeave(endSwipe);\n    onTouchCancel(endSwipe);\n    return state;\n};\n/**\n * useSwipeEvents\n * @param targetRef\n * @param options\n */\nconst useSwipeEvents = (targetRef = null, options = defaultOptions) => {\n    const opts = Object.assign(Object.assign({}, defaultOptions), (options || {}));\n    const [onSwipeLeft, setOnSwipeLeft] = useHandlerSetterRef();\n    const [onSwipeRight, setOnSwipeRight] = useHandlerSetterRef();\n    const [onSwipeUp, setOnSwipeUp] = useHandlerSetterRef();\n    const [onSwipeDown, setOnSwipeDown] = useHandlerSetterRef();\n    const [onSwipeStart, setOnSwipeStart] = useHandlerSetterRef();\n    const [onSwipeMove, setOnSwipeMove] = useHandlerSetterRef();\n    const [onSwipeEnd, setOnSwipeEnd] = useHandlerSetterRef();\n    const state = useSilentSwipeState(targetRef, opts, onSwipeStart.current, onSwipeMove.current, onSwipeEnd.current);\n    const fnMap = {\n        right: onSwipeRight,\n        left: onSwipeLeft,\n        up: onSwipeUp,\n        down: onSwipeDown,\n    };\n    useEffect(() => {\n        if (state && state.direction) {\n            const cb = fnMap[state.direction].current;\n            if (cb && typeof cb === 'function') {\n                cb(state);\n            }\n        }\n    }, [state]);\n    return Object.freeze({\n        onSwipeLeft: setOnSwipeLeft,\n        onSwipeRight: setOnSwipeRight,\n        onSwipeUp: setOnSwipeUp,\n        onSwipeDown: setOnSwipeDown,\n        onSwipeMove: setOnSwipeMove,\n        onSwipeStart: setOnSwipeStart,\n        onSwipeEnd: setOnSwipeEnd,\n    });\n};\nexport default useSwipeEvents;\n"]},"metadata":{},"sourceType":"module"}