{"ast":null,"code":"import useHandlerSetterRef from './shared/useHandlerSetterRef';\nimport createCbSetterErrorProxy from './shared/createCbSetterErrorProxy';\nimport safeHasOwnProperty from './shared/safeHasOwnProperty';\nimport assignEventOnMount from './shared/assignEventOnMount';\n/**\n * Returns a frozen object of callback setters to handle the touch events.<br/>\n * It accepts a DOM ref representing the events target. <br/>\n * If a target is not provided the events will be globally attached to the document object.\n * <br/>\n * ### Shall the `useTouchEvents` callbacks replace the standard mouse handler props?\n *\n * **They shall not!**<br />\n * **useTouchEvents is meant to be used to abstract more complex hooks that need to control mouse**, for instance:\n * a drag n drop hook.<br />\n * Using useTouchEvents handlers instead of the classic props approach it's just as bad as it sounds since you'll\n * lose the React SyntheticEvent performance boost.<br />\n * If you were doing something like the following:\n *\n */\n\nconst useTouchEvents = function () {\n  let targetRef = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  const [onTouchStartHandler, setOnTouchStartHandler] = useHandlerSetterRef();\n  const [onTouchEndHandler, setOnTouchEndHandler] = useHandlerSetterRef();\n  const [onTouchCancelHandler, setOnTouchCancelHandler] = useHandlerSetterRef();\n  const [onTouchMoveHandler, setOnTouchMoveHandler] = useHandlerSetterRef();\n\n  if (targetRef !== null && !safeHasOwnProperty(targetRef, 'current')) {\n    return createCbSetterErrorProxy('Unable to assign any touch event to the given ref');\n  }\n\n  assignEventOnMount(targetRef, onTouchStartHandler, 'touchstart');\n  assignEventOnMount(targetRef, onTouchEndHandler, 'touchend');\n  assignEventOnMount(targetRef, onTouchCancelHandler, 'touchcancel');\n  assignEventOnMount(targetRef, onTouchMoveHandler, 'touchmove');\n  return Object.freeze({\n    onTouchStart: setOnTouchStartHandler,\n    onTouchEnd: setOnTouchEndHandler,\n    onTouchCancel: setOnTouchCancelHandler,\n    onTouchMove: setOnTouchMoveHandler\n  });\n};\n\nexport default useTouchEvents;","map":{"version":3,"sources":["/home/nikita/Desktop/devOps-labs/lab5/react-frontend/node_modules/beautiful-react-hooks/esm/useTouchEvents.js"],"names":["useHandlerSetterRef","createCbSetterErrorProxy","safeHasOwnProperty","assignEventOnMount","useTouchEvents","targetRef","onTouchStartHandler","setOnTouchStartHandler","onTouchEndHandler","setOnTouchEndHandler","onTouchCancelHandler","setOnTouchCancelHandler","onTouchMoveHandler","setOnTouchMoveHandler","Object","freeze","onTouchStart","onTouchEnd","onTouchCancel","onTouchMove"],"mappings":"AAAA,OAAOA,mBAAP,MAAgC,8BAAhC;AACA,OAAOC,wBAAP,MAAqC,mCAArC;AACA,OAAOC,kBAAP,MAA+B,6BAA/B;AACA,OAAOC,kBAAP,MAA+B,6BAA/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,MAAMC,cAAc,GAAG,YAAsB;AAAA,MAArBC,SAAqB,uEAAT,IAAS;AACzC,QAAM,CAACC,mBAAD,EAAsBC,sBAAtB,IAAgDP,mBAAmB,EAAzE;AACA,QAAM,CAACQ,iBAAD,EAAoBC,oBAApB,IAA4CT,mBAAmB,EAArE;AACA,QAAM,CAACU,oBAAD,EAAuBC,uBAAvB,IAAkDX,mBAAmB,EAA3E;AACA,QAAM,CAACY,kBAAD,EAAqBC,qBAArB,IAA8Cb,mBAAmB,EAAvE;;AACA,MAAIK,SAAS,KAAK,IAAd,IAAsB,CAACH,kBAAkB,CAACG,SAAD,EAAY,SAAZ,CAA7C,EAAqE;AACjE,WAAOJ,wBAAwB,CAAC,mDAAD,CAA/B;AACH;;AACDE,EAAAA,kBAAkB,CAACE,SAAD,EAAYC,mBAAZ,EAAiC,YAAjC,CAAlB;AACAH,EAAAA,kBAAkB,CAACE,SAAD,EAAYG,iBAAZ,EAA+B,UAA/B,CAAlB;AACAL,EAAAA,kBAAkB,CAACE,SAAD,EAAYK,oBAAZ,EAAkC,aAAlC,CAAlB;AACAP,EAAAA,kBAAkB,CAACE,SAAD,EAAYO,kBAAZ,EAAgC,WAAhC,CAAlB;AACA,SAAOE,MAAM,CAACC,MAAP,CAAc;AACjBC,IAAAA,YAAY,EAAET,sBADG;AAEjBU,IAAAA,UAAU,EAAER,oBAFK;AAGjBS,IAAAA,aAAa,EAAEP,uBAHE;AAIjBQ,IAAAA,WAAW,EAAEN;AAJI,GAAd,CAAP;AAMH,CAlBD;;AAmBA,eAAeT,cAAf","sourcesContent":["import useHandlerSetterRef from './shared/useHandlerSetterRef';\nimport createCbSetterErrorProxy from './shared/createCbSetterErrorProxy';\nimport safeHasOwnProperty from './shared/safeHasOwnProperty';\nimport assignEventOnMount from './shared/assignEventOnMount';\n/**\n * Returns a frozen object of callback setters to handle the touch events.<br/>\n * It accepts a DOM ref representing the events target. <br/>\n * If a target is not provided the events will be globally attached to the document object.\n * <br/>\n * ### Shall the `useTouchEvents` callbacks replace the standard mouse handler props?\n *\n * **They shall not!**<br />\n * **useTouchEvents is meant to be used to abstract more complex hooks that need to control mouse**, for instance:\n * a drag n drop hook.<br />\n * Using useTouchEvents handlers instead of the classic props approach it's just as bad as it sounds since you'll\n * lose the React SyntheticEvent performance boost.<br />\n * If you were doing something like the following:\n *\n */\nconst useTouchEvents = (targetRef = null) => {\n    const [onTouchStartHandler, setOnTouchStartHandler] = useHandlerSetterRef();\n    const [onTouchEndHandler, setOnTouchEndHandler] = useHandlerSetterRef();\n    const [onTouchCancelHandler, setOnTouchCancelHandler] = useHandlerSetterRef();\n    const [onTouchMoveHandler, setOnTouchMoveHandler] = useHandlerSetterRef();\n    if (targetRef !== null && !safeHasOwnProperty(targetRef, 'current')) {\n        return createCbSetterErrorProxy('Unable to assign any touch event to the given ref');\n    }\n    assignEventOnMount(targetRef, onTouchStartHandler, 'touchstart');\n    assignEventOnMount(targetRef, onTouchEndHandler, 'touchend');\n    assignEventOnMount(targetRef, onTouchCancelHandler, 'touchcancel');\n    assignEventOnMount(targetRef, onTouchMoveHandler, 'touchmove');\n    return Object.freeze({\n        onTouchStart: setOnTouchStartHandler,\n        onTouchEnd: setOnTouchEndHandler,\n        onTouchCancel: setOnTouchCancelHandler,\n        onTouchMove: setOnTouchMoveHandler,\n    });\n};\nexport default useTouchEvents;\n"]},"metadata":{},"sourceType":"module"}